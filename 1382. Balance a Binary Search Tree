Question:

Given the root of a binary search tree, return a balanced binary search tree with the same node values. If there is more than one answer, return any of them.

A binary search tree is balanced if the depth of the two subtrees of every node never differs by more than 1.

Example1:
Original Tree (Left):
  Root: 1
  Node 2 is the right child of 1.
  Node 3 is the right child of 2.
  Node 4 is the right child of 3.

Balanced Tree Option 1 (Top Right):
  Root: 2
  Node 1 is the left child of 2.
  Node 3 is the right child of 2.
  Node 4 is the right child of 3.

Balanced Tree Option 2 (Bottom Right):
  Root: 3
  Node 1 is the left child of 3.
  Node 4 is the right child of 3.
  Node 2 is the right child of 1.

The process shown is a method to balance a binary search tree. 

Input: root = [1,null,2,null,3,null,4,null,null]
Output: [2,1,3,null,null,null,4]
Explanation: This is not the only correct answer, [3,1,4,null,2] is also correct.

Example 2:

-Nodes: There are three circular nodes, explicitly labeled with the numbers 1, 2, and 3.
-Edges:
  An edge connects node 2 to node 1.
  An edge connects node 2 to node 3.
-Structure: Node 2 acts as a central or parent node, with nodes 1 and 3 connected as its children or adjacent nodes.

Input: root = [2,1,3]
Output: [2,1,3]
 

Constraints:

The number of nodes in the tree is in the range [1, 104].
1 <= Node.val <= 10 power 5


Solution (python):

class Solution:
    def balanceBST(self, root):
        vals = []

        def inorder(node):
            if not node:
                return
            inorder(node.left)
            vals.append(node.val)
            inorder(node.right)

        inorder(root)

        def build(l, r):
            if l > r:
                return None
            mid = (l + r) // 2
            node = TreeNode(vals[mid])
            node.left = build(l, mid - 1)
            node.right = build(mid + 1, r)
            return node

        return build(0, len(vals) - 1)
